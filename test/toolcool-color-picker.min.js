/* 
Tool Cool Color Picker v1.0.15
https://github.com/mzusin/toolcool-color-picker
MIT License     
Copyright (c) 2022-present, Miriam Zusin                               
*/
(() => {
  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // src/app/styles.pcss
  var styles_default = ":root{--tool-cool-color-picker-btn-bg:#fff;--tool-cool-color-picker-btn-border-color:#cecece;--tool-cool-color-picker-btn-border-color-inner:#626262;--tool-cool-color-picker-btn-border-radius:.25rem;--tool-cool-color-picker-btn-border-radius-inner:0}.color-picker{position:relative}.button{width:3rem;height:1.5rem;padding:.25rem;background:var(--tool-cool-color-picker-btn-bg,#fff);border-radius:var(--tool-cool-color-picker-btn-border-radius,0.25rem);border-width:1px;border-style:solid;border-color:var(--tool-cool-color-picker-btn-border-color,#cecece);cursor:pointer;box-sizing:border-box}.button-color{display:block;width:100%;height:100%;border-width:1px;border-style:solid;border-color:var(--tool-cool-color-picker-btn-border-color-inner,#626262);background:#000;box-sizing:border-box;border-radius:var(--tool-cool-color-picker-btn-border-radius-inner,0)}";

  // src/ui/popup/popup.pcss
  var popup_default = ":root{--tool-cool-color-picker-popup-bg:#fff;--tool-cool-color-picker-popup-border-color:#cecece;--tool-cool-color-picker-popup-width:214px}.popup{position:absolute;left:0;top:calc(100% - 1px);z-index:50;width:var(--tool-cool-color-picker-popup-width,214px);box-shadow:0 1px 3px 0 rgba(0,0,0,0.1),0 1px 2px -1px rgba(0,0,0,0.1);padding:.5rem;background:var(--tool-cool-color-picker-popup-bg,#fff);border-width:1px;border-style:solid;border-color:var(--tool-cool-color-picker-popup-border-color,#cecece);border-radius:.25rem}.popup.right{right:0;left:auto}";

  // src/ui/themecolors/themecolors.pcss
  var themecolors_default = '.themeColors{display:flex;flex-direction:row;gap:5px;margin-bottom:5px}button{width:24px;height:24px;border:1px solid grey;padding:0;margin:0}button[data-selected="true"]{border:2px solid red}';

  // src/domain/events-provider.ts
  var CUSTOM_EVENT_COLOR_HSV_CHANGED = "tc-hsv-changed";
  var CUSTOM_EVENT_COLOR_HUE_CHANGED = "tc-hue-changed";
  var CUSTOM_EVENT_COLOR_ALPHA_CHANGED = "tc-alpha-changed";
  var CUSTOM_EVENT_BUTTON_CLICKED = "tc-button-clicked";
  var CUSTOM_EVENT_COLOR_INDEX_CHANGED = "tc-color-index-changed";
  var CUSTOM_EVENT_THEME_COLOR_CHANGED = "tc-theme-color-changed";
  var sendButtonClickedCustomEvent = (cid) => {
    if (!cid)
      return;
    document.dispatchEvent(new CustomEvent(CUSTOM_EVENT_BUTTON_CLICKED, {
      detail: {
        cid
      }
    }));
  };
  var sendAlphaCustomEvent = (cid, a) => {
    if (!cid)
      return;
    document.dispatchEvent(new CustomEvent(CUSTOM_EVENT_COLOR_ALPHA_CHANGED, {
      detail: {
        a,
        cid
      }
    }));
  };
  var sendHsvCustomEvent = (cid, h, s, v) => {
    if (!cid)
      return;
    document.dispatchEvent(new CustomEvent(CUSTOM_EVENT_COLOR_HSV_CHANGED, {
      detail: {
        h,
        s,
        v,
        cid
      }
    }));
  };
  var sendHueCustomEvent = (cid, h) => {
    if (!cid)
      return;
    document.dispatchEvent(new CustomEvent(CUSTOM_EVENT_COLOR_HUE_CHANGED, {
      detail: {
        h,
        cid
      }
    }));
  };
  var sendColorIndexCustomEvent = (cid, i) => {
    if (!cid)
      return;
    document.dispatchEvent(new CustomEvent(CUSTOM_EVENT_COLOR_INDEX_CHANGED, {
      detail: {
        i,
        cid
      }
    }));
  };

  // src/ui/themecolors/themecolors.ts
  var ThemeColors = class extends HTMLElement {
    constructor() {
      super();
      __publicField(this, "cid");
      __publicField(this, "$buttonContainer");
      __publicField(this, "$buttons");
      this.attachShadow({
        mode: "open"
      });
      this.handleClick = this.handleClick.bind(this);
    }
    static get observedAttributes() {
      return ["color-index", "theme-colors"];
    }
    handleClick(evt) {
      var _a;
      if (((_a = evt.target) == null ? void 0 : _a.tagName) === "BUTTON") {
        const newIndex = evt.target.getAttribute("data-index");
        if (newIndex != this.getAttribute("color-index")) {
          this.setAttribute("color-index", newIndex);
          sendColorIndexCustomEvent(this.cid, newIndex);
        }
      }
    }
    connectedCallback() {
      var _a, _b, _c;
      if (!this.shadowRoot)
        return;
      this.cid = this.getAttribute("cid") || "";
      this.shadowRoot.innerHTML = `
           <style>${themecolors_default}</style>
           <div class="themeColors">
                <button data-index="0"></button>
                <button data-index="1"></button>
                <button data-index="2"></button>
                <button data-index="3"></button>
                <button data-index="4"></button>
                <button data-index="5"></button>
                <button data-index="6"></button>
                <button data-index="7"></button>
           </div>
        `;
      this.$buttonContainer = this.shadowRoot.querySelector(".themeColors");
      this.$buttons = (_a = this.$buttonContainer) == null ? void 0 : _a.querySelectorAll(`button`);
      (_b = this.$buttonContainer) == null ? void 0 : _b.addEventListener("click", this.handleClick);
      const colors = JSON.parse(this.getAttribute("theme-colors") || "[]");
      const index = parseInt(this.getAttribute("color-index") || "-1");
      (_c = this.$buttons) == null ? void 0 : _c.forEach(($button) => {
        const $btn = $button;
        if (!$btn)
          return;
        const btnIndex = parseInt($btn.getAttribute("data-index") || "-1");
        if (btnIndex === index) {
          $btn.setAttribute("data-selected", "true");
        }
        if (btnIndex >= 0 && btnIndex < colors.length) {
          $btn.style.backgroundColor = colors[btnIndex];
        } else {
          $btn.style.backgroundColor = "";
        }
      });
    }
    disconnectedCallback() {
      var _a;
      (_a = this.$buttonContainer) == null ? void 0 : _a.removeEventListener("click", this.handleClick);
    }
    attributeChangedCallback(_attrName, _oldVal, newVal) {
      var _a, _b;
      if (!this.$buttonContainer)
        return;
      if (_attrName === "theme-colors") {
        const colors = JSON.parse(newVal);
        (_a = this.$buttons) == null ? void 0 : _a.forEach(($button) => {
          const $btn = $button;
          if (!$btn)
            return;
          const btnIndex = parseInt($btn.getAttribute("data-index") || "-1");
          if (btnIndex >= 0 && btnIndex < colors.length) {
            $btn.style.backgroundColor = colors[btnIndex];
          } else {
            $btn.style.backgroundColor = "";
          }
        });
      }
      if (_attrName === "color-index") {
        (_b = this.$buttons) == null ? void 0 : _b.forEach(($button) => {
          const $btn = $button;
          if (!$btn)
            return;
          if ($btn.getAttribute("data-index") === newVal) {
            $btn.setAttribute("data-selected", "true");
          } else {
            $btn.removeAttribute("data-selected");
          }
        });
      }
    }
  };
  var themecolors_default2 = ThemeColors;

  // src/ui/saturation/saturation.pcss
  var saturation_default = ".saturation{touch-action:none;overflow:hidden;width:100%;height:9rem;position:relative}.box{width:100%;height:100%;position:absolute}.white{background:linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.black{background:linear-gradient(0,#000,transparent)}.pointer{top:34.902%;left:18.6747%;cursor:pointer;position:absolute;outline:0}.handler{box-shadow:0 0 0 1.5px #fff,inset 0 0 1px 1px rgb(0,0,0,0.3),0 0 1px 2px rgb(0,0,0,0.4);-webkit-transform:translate(-2px,-2px);transform:translate(-2px,-2px);border-radius:100%;width:.25rem;height:.25rem;outline:0}";

  // node_modules/@ctrl/tinycolor/dist/module/util.js
  function bound01(n, max) {
    if (isOnePointZero(n)) {
      n = "100%";
    }
    var isPercent = isPercentage(n);
    n = max === 360 ? n : Math.min(max, Math.max(0, parseFloat(n)));
    if (isPercent) {
      n = parseInt(String(n * max), 10) / 100;
    }
    if (Math.abs(n - max) < 1e-6) {
      return 1;
    }
    if (max === 360) {
      n = (n < 0 ? n % max + max : n % max) / parseFloat(String(max));
    } else {
      n = n % max / parseFloat(String(max));
    }
    return n;
  }
  function clamp01(val) {
    return Math.min(1, Math.max(0, val));
  }
  function isOnePointZero(n) {
    return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
  }
  function isPercentage(n) {
    return typeof n === "string" && n.indexOf("%") !== -1;
  }
  function boundAlpha(a) {
    a = parseFloat(a);
    if (isNaN(a) || a < 0 || a > 1) {
      a = 1;
    }
    return a;
  }
  function convertToPercentage(n) {
    if (n <= 1) {
      return "".concat(Number(n) * 100, "%");
    }
    return n;
  }
  function pad2(c) {
    return c.length === 1 ? "0" + c : String(c);
  }

  // node_modules/@ctrl/tinycolor/dist/module/conversion.js
  function rgbToRgb(r, g, b) {
    return {
      r: bound01(r, 255) * 255,
      g: bound01(g, 255) * 255,
      b: bound01(b, 255) * 255
    };
  }
  function rgbToHsl(r, g, b) {
    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h = 0;
    var s = 0;
    var l = (max + min) / 2;
    if (max === min) {
      s = 0;
      h = 0;
    } else {
      var d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
        default:
          break;
      }
      h /= 6;
    }
    return { h, s, l };
  }
  function hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }
    if (t > 1) {
      t -= 1;
    }
    if (t < 1 / 6) {
      return p + (q - p) * (6 * t);
    }
    if (t < 1 / 2) {
      return q;
    }
    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
  }
  function hslToRgb(h, s, l) {
    var r;
    var g;
    var b;
    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);
    if (s === 0) {
      g = l;
      b = l;
      r = l;
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }
    return { r: r * 255, g: g * 255, b: b * 255 };
  }
  function rgbToHsv(r, g, b) {
    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h = 0;
    var v = max;
    var d = max - min;
    var s = max === 0 ? 0 : d / max;
    if (max === min) {
      h = 0;
    } else {
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
        default:
          break;
      }
      h /= 6;
    }
    return { h, s, v };
  }
  function hsvToRgb(h, s, v) {
    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);
    var i = Math.floor(h);
    var f = h - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);
    var mod = i % 6;
    var r = [v, q, p, p, t, v][mod];
    var g = [t, v, v, q, p, p][mod];
    var b = [p, p, t, v, v, q][mod];
    return { r: r * 255, g: g * 255, b: b * 255 };
  }
  function rgbToHex(r, g, b, allow3Char) {
    var hex = [
      pad2(Math.round(r).toString(16)),
      pad2(Math.round(g).toString(16)),
      pad2(Math.round(b).toString(16))
    ];
    if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
      return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }
    return hex.join("");
  }
  function rgbaToHex(r, g, b, a, allow4Char) {
    var hex = [
      pad2(Math.round(r).toString(16)),
      pad2(Math.round(g).toString(16)),
      pad2(Math.round(b).toString(16)),
      pad2(convertDecimalToHex(a))
    ];
    if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
      return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    }
    return hex.join("");
  }
  function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
  }
  function convertHexToDecimal(h) {
    return parseIntFromHex(h) / 255;
  }
  function parseIntFromHex(val) {
    return parseInt(val, 16);
  }
  function numberInputToObject(color) {
    return {
      r: color >> 16,
      g: (color & 65280) >> 8,
      b: color & 255
    };
  }

  // node_modules/@ctrl/tinycolor/dist/module/css-color-names.js
  var names = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    goldenrod: "#daa520",
    gold: "#ffd700",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavenderblush: "#fff0f5",
    lavender: "#e6e6fa",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  };

  // node_modules/@ctrl/tinycolor/dist/module/format-input.js
  function inputToRGB(color) {
    var rgb = { r: 0, g: 0, b: 0 };
    var a = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;
    var format = false;
    if (typeof color === "string") {
      color = stringInputToObject(color);
    }
    if (typeof color === "object") {
      if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
        rgb = rgbToRgb(color.r, color.g, color.b);
        ok = true;
        format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
      } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
        s = convertToPercentage(color.s);
        v = convertToPercentage(color.v);
        rgb = hsvToRgb(color.h, s, v);
        ok = true;
        format = "hsv";
      } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
        s = convertToPercentage(color.s);
        l = convertToPercentage(color.l);
        rgb = hslToRgb(color.h, s, l);
        ok = true;
        format = "hsl";
      }
      if (Object.prototype.hasOwnProperty.call(color, "a")) {
        a = color.a;
      }
    }
    a = boundAlpha(a);
    return {
      ok,
      format: color.format || format,
      r: Math.min(255, Math.max(rgb.r, 0)),
      g: Math.min(255, Math.max(rgb.g, 0)),
      b: Math.min(255, Math.max(rgb.b, 0)),
      a
    };
  }
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
  var matchers = {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
  function stringInputToObject(color) {
    color = color.trim().toLowerCase();
    if (color.length === 0) {
      return false;
    }
    var named = false;
    if (names[color]) {
      color = names[color];
      named = true;
    } else if (color === "transparent") {
      return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    }
    var match = matchers.rgb.exec(color);
    if (match) {
      return { r: match[1], g: match[2], b: match[3] };
    }
    match = matchers.rgba.exec(color);
    if (match) {
      return { r: match[1], g: match[2], b: match[3], a: match[4] };
    }
    match = matchers.hsl.exec(color);
    if (match) {
      return { h: match[1], s: match[2], l: match[3] };
    }
    match = matchers.hsla.exec(color);
    if (match) {
      return { h: match[1], s: match[2], l: match[3], a: match[4] };
    }
    match = matchers.hsv.exec(color);
    if (match) {
      return { h: match[1], s: match[2], v: match[3] };
    }
    match = matchers.hsva.exec(color);
    if (match) {
      return { h: match[1], s: match[2], v: match[3], a: match[4] };
    }
    match = matchers.hex8.exec(color);
    if (match) {
      return {
        r: parseIntFromHex(match[1]),
        g: parseIntFromHex(match[2]),
        b: parseIntFromHex(match[3]),
        a: convertHexToDecimal(match[4]),
        format: named ? "name" : "hex8"
      };
    }
    match = matchers.hex6.exec(color);
    if (match) {
      return {
        r: parseIntFromHex(match[1]),
        g: parseIntFromHex(match[2]),
        b: parseIntFromHex(match[3]),
        format: named ? "name" : "hex"
      };
    }
    match = matchers.hex4.exec(color);
    if (match) {
      return {
        r: parseIntFromHex(match[1] + match[1]),
        g: parseIntFromHex(match[2] + match[2]),
        b: parseIntFromHex(match[3] + match[3]),
        a: convertHexToDecimal(match[4] + match[4]),
        format: named ? "name" : "hex8"
      };
    }
    match = matchers.hex3.exec(color);
    if (match) {
      return {
        r: parseIntFromHex(match[1] + match[1]),
        g: parseIntFromHex(match[2] + match[2]),
        b: parseIntFromHex(match[3] + match[3]),
        format: named ? "name" : "hex"
      };
    }
    return false;
  }
  function isValidCSSUnit(color) {
    return Boolean(matchers.CSS_UNIT.exec(String(color)));
  }

  // node_modules/@ctrl/tinycolor/dist/module/index.js
  var TinyColor = function() {
    function TinyColor2(color, opts) {
      if (color === void 0) {
        color = "";
      }
      if (opts === void 0) {
        opts = {};
      }
      var _a;
      if (color instanceof TinyColor2) {
        return color;
      }
      if (typeof color === "number") {
        color = numberInputToObject(color);
      }
      this.originalInput = color;
      var rgb = inputToRGB(color);
      this.originalInput = color;
      this.r = rgb.r;
      this.g = rgb.g;
      this.b = rgb.b;
      this.a = rgb.a;
      this.roundA = Math.round(100 * this.a) / 100;
      this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format;
      this.gradientType = opts.gradientType;
      if (this.r < 1) {
        this.r = Math.round(this.r);
      }
      if (this.g < 1) {
        this.g = Math.round(this.g);
      }
      if (this.b < 1) {
        this.b = Math.round(this.b);
      }
      this.isValid = rgb.ok;
    }
    TinyColor2.prototype.isDark = function() {
      return this.getBrightness() < 128;
    };
    TinyColor2.prototype.isLight = function() {
      return !this.isDark();
    };
    TinyColor2.prototype.getBrightness = function() {
      var rgb = this.toRgb();
      return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
    };
    TinyColor2.prototype.getLuminance = function() {
      var rgb = this.toRgb();
      var R;
      var G;
      var B;
      var RsRGB = rgb.r / 255;
      var GsRGB = rgb.g / 255;
      var BsRGB = rgb.b / 255;
      if (RsRGB <= 0.03928) {
        R = RsRGB / 12.92;
      } else {
        R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
      }
      if (GsRGB <= 0.03928) {
        G = GsRGB / 12.92;
      } else {
        G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
      }
      if (BsRGB <= 0.03928) {
        B = BsRGB / 12.92;
      } else {
        B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
      }
      return 0.2126 * R + 0.7152 * G + 0.0722 * B;
    };
    TinyColor2.prototype.getAlpha = function() {
      return this.a;
    };
    TinyColor2.prototype.setAlpha = function(alpha) {
      this.a = boundAlpha(alpha);
      this.roundA = Math.round(100 * this.a) / 100;
      return this;
    };
    TinyColor2.prototype.isMonochrome = function() {
      var s = this.toHsl().s;
      return s === 0;
    };
    TinyColor2.prototype.toHsv = function() {
      var hsv = rgbToHsv(this.r, this.g, this.b);
      return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
    };
    TinyColor2.prototype.toHsvString = function() {
      var hsv = rgbToHsv(this.r, this.g, this.b);
      var h = Math.round(hsv.h * 360);
      var s = Math.round(hsv.s * 100);
      var v = Math.round(hsv.v * 100);
      return this.a === 1 ? "hsv(".concat(h, ", ").concat(s, "%, ").concat(v, "%)") : "hsva(".concat(h, ", ").concat(s, "%, ").concat(v, "%, ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toHsl = function() {
      var hsl = rgbToHsl(this.r, this.g, this.b);
      return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
    };
    TinyColor2.prototype.toHslString = function() {
      var hsl = rgbToHsl(this.r, this.g, this.b);
      var h = Math.round(hsl.h * 360);
      var s = Math.round(hsl.s * 100);
      var l = Math.round(hsl.l * 100);
      return this.a === 1 ? "hsl(".concat(h, ", ").concat(s, "%, ").concat(l, "%)") : "hsla(".concat(h, ", ").concat(s, "%, ").concat(l, "%, ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toHex = function(allow3Char) {
      if (allow3Char === void 0) {
        allow3Char = false;
      }
      return rgbToHex(this.r, this.g, this.b, allow3Char);
    };
    TinyColor2.prototype.toHexString = function(allow3Char) {
      if (allow3Char === void 0) {
        allow3Char = false;
      }
      return "#" + this.toHex(allow3Char);
    };
    TinyColor2.prototype.toHex8 = function(allow4Char) {
      if (allow4Char === void 0) {
        allow4Char = false;
      }
      return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
    };
    TinyColor2.prototype.toHex8String = function(allow4Char) {
      if (allow4Char === void 0) {
        allow4Char = false;
      }
      return "#" + this.toHex8(allow4Char);
    };
    TinyColor2.prototype.toHexShortString = function(allowShortChar) {
      if (allowShortChar === void 0) {
        allowShortChar = false;
      }
      return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
    };
    TinyColor2.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    };
    TinyColor2.prototype.toRgbString = function() {
      var r = Math.round(this.r);
      var g = Math.round(this.g);
      var b = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toPercentageRgb = function() {
      var fmt = function(x) {
        return "".concat(Math.round(bound01(x, 255) * 100), "%");
      };
      return {
        r: fmt(this.r),
        g: fmt(this.g),
        b: fmt(this.b),
        a: this.a
      };
    };
    TinyColor2.prototype.toPercentageRgbString = function() {
      var rnd = function(x) {
        return Math.round(bound01(x, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toName = function() {
      if (this.a === 0) {
        return "transparent";
      }
      if (this.a < 1) {
        return false;
      }
      var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
      for (var _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {
        var _b = _a[_i], key = _b[0], value = _b[1];
        if (hex === value) {
          return key;
        }
      }
      return false;
    };
    TinyColor2.prototype.toString = function(format) {
      var formatSet = Boolean(format);
      format = format !== null && format !== void 0 ? format : this.format;
      var formattedString = false;
      var hasAlpha = this.a < 1 && this.a >= 0;
      var needsAlphaFormat = !formatSet && hasAlpha && (format.startsWith("hex") || format === "name");
      if (needsAlphaFormat) {
        if (format === "name" && this.a === 0) {
          return this.toName();
        }
        return this.toRgbString();
      }
      if (format === "rgb") {
        formattedString = this.toRgbString();
      }
      if (format === "prgb") {
        formattedString = this.toPercentageRgbString();
      }
      if (format === "hex" || format === "hex6") {
        formattedString = this.toHexString();
      }
      if (format === "hex3") {
        formattedString = this.toHexString(true);
      }
      if (format === "hex4") {
        formattedString = this.toHex8String(true);
      }
      if (format === "hex8") {
        formattedString = this.toHex8String();
      }
      if (format === "name") {
        formattedString = this.toName();
      }
      if (format === "hsl") {
        formattedString = this.toHslString();
      }
      if (format === "hsv") {
        formattedString = this.toHsvString();
      }
      return formattedString || this.toHexString();
    };
    TinyColor2.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    };
    TinyColor2.prototype.clone = function() {
      return new TinyColor2(this.toString());
    };
    TinyColor2.prototype.lighten = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.l += amount / 100;
      hsl.l = clamp01(hsl.l);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.brighten = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var rgb = this.toRgb();
      rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
      rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
      rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
      return new TinyColor2(rgb);
    };
    TinyColor2.prototype.darken = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.l -= amount / 100;
      hsl.l = clamp01(hsl.l);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.tint = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      return this.mix("white", amount);
    };
    TinyColor2.prototype.shade = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      return this.mix("black", amount);
    };
    TinyColor2.prototype.desaturate = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.s -= amount / 100;
      hsl.s = clamp01(hsl.s);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.saturate = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.s += amount / 100;
      hsl.s = clamp01(hsl.s);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.greyscale = function() {
      return this.desaturate(100);
    };
    TinyColor2.prototype.spin = function(amount) {
      var hsl = this.toHsl();
      var hue = (hsl.h + amount) % 360;
      hsl.h = hue < 0 ? 360 + hue : hue;
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.mix = function(color, amount) {
      if (amount === void 0) {
        amount = 50;
      }
      var rgb1 = this.toRgb();
      var rgb2 = new TinyColor2(color).toRgb();
      var p = amount / 100;
      var rgba = {
        r: (rgb2.r - rgb1.r) * p + rgb1.r,
        g: (rgb2.g - rgb1.g) * p + rgb1.g,
        b: (rgb2.b - rgb1.b) * p + rgb1.b,
        a: (rgb2.a - rgb1.a) * p + rgb1.a
      };
      return new TinyColor2(rgba);
    };
    TinyColor2.prototype.analogous = function(results, slices) {
      if (results === void 0) {
        results = 6;
      }
      if (slices === void 0) {
        slices = 30;
      }
      var hsl = this.toHsl();
      var part = 360 / slices;
      var ret = [this];
      for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(new TinyColor2(hsl));
      }
      return ret;
    };
    TinyColor2.prototype.complement = function() {
      var hsl = this.toHsl();
      hsl.h = (hsl.h + 180) % 360;
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.monochromatic = function(results) {
      if (results === void 0) {
        results = 6;
      }
      var hsv = this.toHsv();
      var h = hsv.h;
      var s = hsv.s;
      var v = hsv.v;
      var res = [];
      var modification = 1 / results;
      while (results--) {
        res.push(new TinyColor2({ h, s, v }));
        v = (v + modification) % 1;
      }
      return res;
    };
    TinyColor2.prototype.splitcomplement = function() {
      var hsl = this.toHsl();
      var h = hsl.h;
      return [
        this,
        new TinyColor2({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),
        new TinyColor2({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })
      ];
    };
    TinyColor2.prototype.onBackground = function(background) {
      var fg = this.toRgb();
      var bg = new TinyColor2(background).toRgb();
      var alpha = fg.a + bg.a * (1 - fg.a);
      return new TinyColor2({
        r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
        g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
        b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
        a: alpha
      });
    };
    TinyColor2.prototype.triad = function() {
      return this.polyad(3);
    };
    TinyColor2.prototype.tetrad = function() {
      return this.polyad(4);
    };
    TinyColor2.prototype.polyad = function(n) {
      var hsl = this.toHsl();
      var h = hsl.h;
      var result = [this];
      var increment = 360 / n;
      for (var i = 1; i < n; i++) {
        result.push(new TinyColor2({ h: (h + i * increment) % 360, s: hsl.s, l: hsl.l }));
      }
      return result;
    };
    TinyColor2.prototype.equals = function(color) {
      return this.toRgbString() === new TinyColor2(color).toRgbString();
    };
    return TinyColor2;
  }();

  // src/domain/common-provider.ts
  var getUniqueId = () => {
    return Math.random().toString(16).slice(2);
  };
  var round2places = (num) => {
    return Math.round((num + Number.EPSILON) * 100) / 100;
  };

  // src/domain/color-provider.ts
  var SATURATION_STEP = 0.01;
  var getHueBackground = (hue) => {
    if (hue < 0) {
      hue = 0;
    }
    if (hue > 360) {
      hue = 360;
    }
    return `hsl(${Math.round(hue)}, 100%, 50%)`;
  };
  var getAlphaColorBackground = (color) => {
    const rgba = color.toRgb();
    return `linear-gradient(to right, rgba(${rgba.r},${rgba.g},${rgba.b}, 0) 0%, rgba(${rgba.r},${rgba.g},${rgba.b}, 1) 100%)`;
  };
  var rgbaToString = (color) => {
    const rgba = color.toRgb();
    return `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${round2places(rgba.a)})`;
  };
  var hslaToString = (color) => {
    const hsla = color.toHsl();
    return `hsla(${Math.round(hsla.h)}, ${Math.round(hsla.s * 100)}%, ${Math.round(hsla.l * 100)}%, ${round2places(hsla.a)})`;
  };
  var hsvaToString = (color) => {
    const hsva = color.toHsv();
    return `hsva(${Math.round(hsva.h)}, ${Math.round(hsva.s * 100)}%, ${Math.round(hsva.v * 100)}%, ${round2places(hsva.a)})`;
  };
  var getTopByValue = (value) => {
    if (value < 0) {
      value = 0;
    }
    if (value > 1) {
      value = 1;
    }
    const top = -(value * 100) + 100;
    return `${top.toFixed(2)}%`;
  };
  var getLeftBySaturation = (saturation) => {
    if (saturation < 0) {
      saturation = 0;
    }
    if (saturation > 1) {
      saturation = 1;
    }
    const top = saturation * 100;
    return `${top.toFixed(2)}%`;
  };
  var getLeftByHue = (hue) => {
    if (hue < 0) {
      hue = 0;
    }
    if (hue > 360) {
      hue = 360;
    }
    const left = hue * 100 / 360;
    let rounded = Math.round(left * 100) / 100;
    if (rounded < 0) {
      rounded = 0;
    }
    if (rounded > 100) {
      rounded = 100;
    }
    return rounded;
  };
  var getHueByLeft = (left) => {
    return 360 * left / 100;
  };
  var fixRGB = (updatedValue) => {
    let value = Number(updatedValue) || 0;
    value = Math.round(value);
    value = Math.max(0, value);
    value = Math.min(255, value);
    return value;
  };
  var fixPercent = (updatedValue) => {
    let value = Number(updatedValue) || 100;
    value = Math.round(value);
    value = Math.max(0, value);
    value = Math.min(100, value);
    return value;
  };
  var parseColor = (colorString) => {
    const color = new TinyColor(colorString || "#000");
    color.setAlpha(color.getAlpha());
    return color;
  };

  // src/ui/saturation/saturation.ts
  var Saturation = class extends HTMLElement {
    constructor() {
      super();
      __publicField(this, "cid");
      __publicField(this, "$saturation");
      __publicField(this, "$color");
      __publicField(this, "$pointer");
      __publicField(this, "hue", 0);
      __publicField(this, "saturation", 0);
      __publicField(this, "value", 0);
      this.attachShadow({
        mode: "open"
      });
      this.onMouseDown = this.onMouseDown.bind(this);
      this.onMouseUp = this.onMouseUp.bind(this);
      this.onChange = this.onChange.bind(this);
      this.onPointerKeyDown = this.onPointerKeyDown.bind(this);
      this.hsvChanged = this.hsvChanged.bind(this);
      this.hueChanged = this.hueChanged.bind(this);
    }
    static get observedAttributes() {
      return ["color"];
    }
    render(sendEvent) {
      if (this.$pointer) {
        this.$pointer.style.left = getLeftBySaturation(this.saturation);
        this.$pointer.style.top = getTopByValue(this.value);
      }
      if (this.$color) {
        this.$color.setAttribute("style", `background: ${getHueBackground(this.hue)}`);
      }
      if (sendEvent) {
        sendHsvCustomEvent(this.cid, this.hue, this.saturation, this.value);
      }
    }
    onChange(evt) {
      if (!this.$saturation)
        return;
      const { width: boxWidth, height: boxHeight, left: boxLeft, top: boxTop } = this.$saturation.getBoundingClientRect();
      if (boxWidth === 0 || boxHeight === 0)
        return;
      const mouseX = typeof evt.clientX === "number" ? evt.clientX : evt.touches[0].clientX;
      const mouseY = typeof evt.clientY === "number" ? evt.clientY : evt.touches[0].clientY;
      const lPos = Math.min(Math.max(0, mouseX - boxLeft), boxWidth);
      const tPos = Math.min(Math.max(0, mouseY - boxTop), boxHeight);
      this.saturation = lPos / boxWidth;
      this.value = 1 - tPos / boxHeight;
      this.render(true);
    }
    onPointerKeyDown(evt) {
      switch (evt.key) {
        case "ArrowLeft": {
          this.saturation = Math.max(0, this.saturation - SATURATION_STEP);
          this.render(true);
          break;
        }
        case "ArrowRight": {
          this.saturation = Math.min(1, this.saturation + SATURATION_STEP);
          this.render(true);
          break;
        }
        case "ArrowUp": {
          this.value = Math.min(1, this.value + SATURATION_STEP);
          this.render(true);
          break;
        }
        case "ArrowDown": {
          evt.preventDefault();
          this.value = Math.max(0, this.value - SATURATION_STEP);
          this.render(true);
          break;
        }
      }
    }
    onMouseDown(evt) {
      if (evt.preventDefault) {
        evt.preventDefault();
      }
      this.onChange(evt);
      window.addEventListener("mousemove", this.onChange);
      window.addEventListener("mouseup", this.onMouseUp);
      window.setTimeout(() => {
        var _a;
        (_a = this.$pointer) == null ? void 0 : _a.focus();
      }, 0);
    }
    onMouseUp() {
      window.removeEventListener("mousemove", this.onChange);
      window.removeEventListener("mouseup", this.onChange);
    }
    hsvChanged(evt) {
      if (!evt || !evt.detail || !evt.detail.cid)
        return;
      if (evt.detail.cid !== this.cid)
        return;
      let changed = false;
      if (this.hue !== evt.detail.h) {
        this.hue = evt.detail.h;
        changed = true;
      }
      if (this.saturation !== evt.detail.s) {
        this.saturation = evt.detail.s;
        changed = true;
      }
      if (this.value !== evt.detail.v) {
        this.value = evt.detail.v;
        changed = true;
      }
      if (changed) {
        this.render(false);
      }
    }
    hueChanged(evt) {
      if (!evt || !evt.detail || !evt.detail.cid)
        return;
      if (evt.detail.cid !== this.cid)
        return;
      this.hue = evt.detail.h;
      this.render(false);
    }
    connectedCallback() {
      var _a, _b, _c, _d, _e;
      if (!this.shadowRoot)
        return;
      this.cid = this.getAttribute("cid") || "";
      const color = parseColor(this.getAttribute("color"));
      const hsv = color.toHsv();
      this.hue = hsv.h;
      this.saturation = hsv.s;
      this.value = hsv.v;
      const top = getTopByValue(this.value);
      const left = getLeftBySaturation(this.saturation);
      this.shadowRoot.innerHTML = `
           <style>${saturation_default}</style>
           <div class="saturation">
                <div class="box" style="background: ${getHueBackground(this.hue)}">
                    <div class="white box">
                        <div class="black box"></div>
                        
                        <div class="pointer" tabindex="0" style="top: ${top}; left: ${left};">
                            <div class="handler"></div>
                        </div>
                    </div>
                </div>
           </div>
        `;
      this.$saturation = this.shadowRoot.querySelector(".saturation");
      this.$color = this.shadowRoot.querySelector(".box");
      this.$pointer = this.shadowRoot.querySelector(".pointer");
      (_a = this.$pointer) == null ? void 0 : _a.addEventListener("keydown", this.onPointerKeyDown);
      (_b = this.$saturation) == null ? void 0 : _b.addEventListener("mousedown", this.onMouseDown);
      (_c = this.$saturation) == null ? void 0 : _c.addEventListener("mouseup", this.onMouseUp);
      (_d = this.$saturation) == null ? void 0 : _d.addEventListener("touchmove", this.onChange);
      (_e = this.$saturation) == null ? void 0 : _e.addEventListener("touchstart", this.onChange);
      document.addEventListener(CUSTOM_EVENT_COLOR_HSV_CHANGED, this.hsvChanged);
      document.addEventListener(CUSTOM_EVENT_COLOR_HUE_CHANGED, this.hueChanged);
    }
    disconnectedCallback() {
      var _a, _b, _c, _d, _e;
      (_a = this.$saturation) == null ? void 0 : _a.removeEventListener("mousedown", this.onMouseDown);
      (_b = this.$saturation) == null ? void 0 : _b.removeEventListener("mouseup", this.onMouseUp);
      (_c = this.$saturation) == null ? void 0 : _c.removeEventListener("touchmove", this.onChange);
      (_d = this.$saturation) == null ? void 0 : _d.removeEventListener("touchstart", this.onChange);
      (_e = this.$pointer) == null ? void 0 : _e.removeEventListener("keydown", this.onPointerKeyDown);
      document.removeEventListener(CUSTOM_EVENT_COLOR_HSV_CHANGED, this.hsvChanged);
      document.removeEventListener(CUSTOM_EVENT_COLOR_HUE_CHANGED, this.hueChanged);
    }
    attributeChangedCallback(_attrName, _oldVal, newVal) {
      const color = parseColor(newVal);
      const hsv = color.toHsv();
      this.hue = hsv.h;
      this.saturation = hsv.s;
      this.value = hsv.v;
      this.render(false);
    }
  };
  var saturation_default2 = Saturation;

  // src/ui/hue/hue.pcss
  var hue_default = ".hue{overflow:hidden;height:.625rem;margin-bottom:.25rem;margin-top:.25rem;position:relative}.box{width:100%;height:100%;position:absolute}.hue-v{background:linear-gradient(0,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.hue-h{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red);width:100%;height:100%;position:relative}.pointer-box{left:87%;position:absolute;outline:0}.handler{background:#fff;box-shadow:0 0 2px rgb(0 0 0 / 60%);box-sizing:border-box;border:1px solid hsla(0,0%,88%,.5);height:8px;margin-top:1px;-webkit-transform:translateX(-4px);transform:translateX(-4px);width:8px;cursor:pointer;outline:0}.pointer-box:focus .handler{border:2px solid hsla(0,0%,88%,1)}";

  // src/ui/hue/hue.ts
  var Hue = class extends HTMLElement {
    constructor() {
      super();
      __publicField(this, "cid");
      __publicField(this, "$hue");
      __publicField(this, "$pointer");
      __publicField(this, "hue", 0);
      this.attachShadow({
        mode: "open"
      });
      this.onMouseDown = this.onMouseDown.bind(this);
      this.onMouseUp = this.onMouseUp.bind(this);
      this.onChange = this.onChange.bind(this);
      this.onKeyDown = this.onKeyDown.bind(this);
      this.hsvChanged = this.hsvChanged.bind(this);
    }
    static get observedAttributes() {
      return ["color"];
    }
    render(sendEvent) {
      if (this.$pointer) {
        this.$pointer.style.left = `${getLeftByHue(this.hue)}%`;
      }
      if (sendEvent)
        sendHueCustomEvent(this.cid, this.hue);
    }
    hsvChanged(evt) {
      if (!evt || !evt.detail || !evt.detail.cid)
        return;
      if (evt.detail.cid !== this.cid)
        return;
      if (this.hue !== evt.detail.h) {
        this.hue = evt.detail.h;
        this.render(false);
      }
    }
    onChange(evt) {
      if (!this.$hue)
        return;
      if (evt.preventDefault) {
        evt.preventDefault();
      }
      const { width: boxWidth, left: boxLeft } = this.$hue.getBoundingClientRect();
      if (boxWidth === 0)
        return;
      const mouseX = typeof evt.clientX === "number" ? evt.clientX : evt.touches[0].clientX;
      const left = Math.min(Math.max(0, mouseX - boxLeft), boxWidth);
      const percent = Math.min(Math.max(0, Math.round(left * 100 / boxWidth)), 100);
      this.hue = getHueByLeft(percent);
      this.render(true);
    }
    onKeyDown(evt) {
      var _a;
      (_a = this.$pointer) == null ? void 0 : _a.focus();
      switch (evt.key) {
        case "ArrowLeft": {
          let percent = getLeftByHue(this.hue);
          percent = Math.max(0, percent - 1);
          this.hue = getHueByLeft(percent);
          this.render(true);
          break;
        }
        case "ArrowRight": {
          let percent = getLeftByHue(this.hue);
          percent = Math.min(100, percent + 1);
          this.hue = getHueByLeft(percent);
          this.render(true);
          break;
        }
      }
    }
    onMouseDown(evt) {
      if (evt.preventDefault) {
        evt.preventDefault();
      }
      this.onChange(evt);
      window.addEventListener("mousemove", this.onChange);
      window.addEventListener("mouseup", this.onMouseUp);
      window.setTimeout(() => {
        var _a;
        (_a = this.$pointer) == null ? void 0 : _a.focus();
      }, 0);
    }
    onMouseUp() {
      window.removeEventListener("mousemove", this.onChange);
      window.removeEventListener("mouseup", this.onChange);
    }
    connectedCallback() {
      var _a, _b, _c, _d, _e;
      if (!this.shadowRoot)
        return;
      this.cid = this.getAttribute("cid") || "";
      const color = parseColor(this.getAttribute("color"));
      this.hue = color.toHsv().h;
      this.shadowRoot.innerHTML = `
           <style>${hue_default}</style>
           <div class="hue">
                <div class="box">
                    <div class="hue-v box">
                        <div class="hue-h"></div>
                    </div>
                    
                    <div class="pointer box">
                        <div class="pointer-box" tabindex="0" style="left: ${getLeftByHue(this.hue)}%">
                            <div class="handler"></div>
                        </div>
                    </div>
                </div>
           </div>
        `;
      this.$hue = this.shadowRoot.querySelector(".hue");
      this.$pointer = this.shadowRoot.querySelector(".pointer-box");
      (_a = this.$hue) == null ? void 0 : _a.addEventListener("mousedown", this.onMouseDown);
      (_b = this.$hue) == null ? void 0 : _b.addEventListener("mouseup", this.onMouseUp);
      (_c = this.$hue) == null ? void 0 : _c.addEventListener("touchmove", this.onChange);
      (_d = this.$hue) == null ? void 0 : _d.addEventListener("touchstart", this.onChange);
      (_e = this.$pointer) == null ? void 0 : _e.addEventListener("keydown", this.onKeyDown);
      document.addEventListener(CUSTOM_EVENT_COLOR_HSV_CHANGED, this.hsvChanged);
    }
    disconnectedCallback() {
      var _a, _b, _c, _d, _e;
      (_a = this.$hue) == null ? void 0 : _a.removeEventListener("mousedown", this.onMouseDown);
      (_b = this.$hue) == null ? void 0 : _b.removeEventListener("mouseup", this.onMouseUp);
      (_c = this.$hue) == null ? void 0 : _c.removeEventListener("touchmove", this.onChange);
      (_d = this.$hue) == null ? void 0 : _d.removeEventListener("touchstart", this.onChange);
      (_e = this.$pointer) == null ? void 0 : _e.removeEventListener("keydown", this.onKeyDown);
      document.removeEventListener(CUSTOM_EVENT_COLOR_HSV_CHANGED, this.hsvChanged);
    }
    attributeChangedCallback(_attrName, _oldVal, newVal) {
      const color = parseColor(newVal);
      const hsv = color.toHsv();
      this.hue = hsv.h;
      this.render(false);
    }
  };
  var hue_default2 = Hue;

  // src/ui/alpha/alpha.pcss
  var alpha_default = ".alpha{overflow:hidden;height:.625rem;position:relative;background:#fff}.box{width:100%;height:100%;position:absolute}.transparent-bg{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAADFJREFUOE9jZGBgEGHAD97gk2YcNYBhmIQBgWSAP52AwoAQwJvQRg1gACckQoC2gQgAIF8IscwEtKYAAAAASUVORK5CYII=);overflow:hidden}.pointer-box{left:100%;position:absolute;outline:0}.handler{background:#fff;box-shadow:0 0 2px rgb(0 0 0 / 60%);box-sizing:border-box;border:1px solid hsla(0,0%,88%,.5);height:8px;margin-top:1px;-webkit-transform:translateX(-4px);transform:translateX(-4px);width:8px;cursor:pointer;outline:0}.alpha-pointer-box:focus .alpha-pointer-handler{border:2px solid hsla(0,0%,88%,1)}";

  // src/ui/alpha/alpha.ts
  var Alpha = class extends HTMLElement {
    constructor() {
      super();
      __publicField(this, "cid");
      __publicField(this, "$alpha");
      __publicField(this, "$color");
      __publicField(this, "$pointer");
      __publicField(this, "alpha", 1);
      __publicField(this, "hue", 0);
      __publicField(this, "saturation", 0);
      __publicField(this, "value", 0);
      this.attachShadow({
        mode: "open"
      });
      this.onMouseDown = this.onMouseDown.bind(this);
      this.onMouseUp = this.onMouseUp.bind(this);
      this.onChange = this.onChange.bind(this);
      this.onKeyDown = this.onKeyDown.bind(this);
      this.hsvChanged = this.hsvChanged.bind(this);
      this.hueChanged = this.hueChanged.bind(this);
      this.alphaChanged = this.alphaChanged.bind(this);
    }
    static get observedAttributes() {
      return ["color"];
    }
    render(sendEvent) {
      if (this.$pointer) {
        this.$pointer.style.left = `${this.alpha * 100}%`;
      }
      if (this.$color) {
        const color = new TinyColor({
          h: this.hue,
          s: this.saturation,
          v: this.value,
          a: this.alpha
        });
        this.$color.style.background = getAlphaColorBackground(color);
      }
      if (sendEvent) {
        sendAlphaCustomEvent(this.cid, this.alpha);
      }
    }
    onChange(evt) {
      if (!this.$alpha)
        return;
      if (evt.preventDefault) {
        evt.preventDefault();
      }
      const { width: boxWidth, left: boxLeft } = this.$alpha.getBoundingClientRect();
      if (boxWidth === 0)
        return;
      const mouseX = typeof evt.clientX === "number" ? evt.clientX : evt.touches[0].clientX;
      const left = Math.min(Math.max(0, mouseX - boxLeft), boxWidth);
      const percent = Math.min(Math.max(0, left * 100 / boxWidth), 100);
      this.alpha = percent / 100;
      this.render(true);
    }
    onKeyDown(evt) {
      var _a;
      (_a = this.$pointer) == null ? void 0 : _a.focus();
      switch (evt.key) {
        case "ArrowLeft": {
          let percent = this.alpha * 100;
          percent = Math.max(0, percent - 1);
          this.alpha = percent / 100;
          this.render(true);
          break;
        }
        case "ArrowRight": {
          let percent = this.alpha * 100;
          percent = Math.min(100, percent + 1);
          this.alpha = percent / 100;
          this.render(true);
          break;
        }
      }
    }
    hsvChanged(evt) {
      if (!evt || !evt.detail || !evt.detail.cid)
        return;
      if (evt.detail.cid !== this.cid)
        return;
      this.saturation = evt.detail.s;
      this.hue = evt.detail.h;
      this.value = evt.detail.v;
      this.render(false);
    }
    hueChanged(evt) {
      if (!evt || !evt.detail || !evt.detail.cid)
        return;
      if (evt.detail.cid !== this.cid)
        return;
      this.hue = evt.detail.h;
      this.render(false);
    }
    alphaChanged(evt) {
      if (!evt || !evt.detail || !evt.detail.cid)
        return;
      if (evt.detail.cid !== this.cid)
        return;
      if (this.alpha !== evt.detail.a) {
        this.alpha = evt.detail.a;
        this.render(true);
      }
    }
    onMouseDown(evt) {
      if (evt.preventDefault) {
        evt.preventDefault();
      }
      this.onChange(evt);
      window.addEventListener("mousemove", this.onChange);
      window.addEventListener("mouseup", this.onMouseUp);
      window.setTimeout(() => {
        var _a;
        (_a = this.$pointer) == null ? void 0 : _a.focus();
      }, 0);
    }
    onMouseUp() {
      window.removeEventListener("mousemove", this.onChange);
      window.removeEventListener("mouseup", this.onChange);
    }
    connectedCallback() {
      var _a, _b, _c, _d, _e;
      if (!this.shadowRoot)
        return;
      this.cid = this.getAttribute("cid") || "";
      const color = parseColor(this.getAttribute("color"));
      const hsv = color.toHsv();
      this.alpha = hsv.a;
      this.hue = hsv.h;
      this.saturation = hsv.s;
      this.value = hsv.v;
      this.shadowRoot.innerHTML = `
           <style>${alpha_default}</style>
           <div class="alpha">
                <div class="box">
                    <div class="transparent-bg box"></div>
                    <div class="color-bg box" style="background: ${getAlphaColorBackground(color)}"></div>
                    
                    <div class="pointer box">
                        <div class="pointer-box" tabindex="0" style="left: ${this.alpha * 100}%;" >
                            <div class="handler"></div>
                        </div>
                    </div>
                </div>
           </div>
        `;
      this.$alpha = this.shadowRoot.querySelector(".alpha");
      this.$color = this.shadowRoot.querySelector(".color-bg");
      this.$pointer = this.shadowRoot.querySelector(".pointer-box");
      (_a = this.$alpha) == null ? void 0 : _a.addEventListener("mousedown", this.onMouseDown);
      (_b = this.$alpha) == null ? void 0 : _b.addEventListener("mouseup", this.onMouseUp);
      (_c = this.$alpha) == null ? void 0 : _c.addEventListener("touchmove", this.onChange);
      (_d = this.$alpha) == null ? void 0 : _d.addEventListener("touchstart", this.onChange);
      (_e = this.$pointer) == null ? void 0 : _e.addEventListener("keydown", this.onKeyDown);
      document.addEventListener(CUSTOM_EVENT_COLOR_HSV_CHANGED, this.hsvChanged);
      document.addEventListener(CUSTOM_EVENT_COLOR_HUE_CHANGED, this.hueChanged);
      document.addEventListener(CUSTOM_EVENT_COLOR_ALPHA_CHANGED, this.alphaChanged);
    }
    disconnectedCallback() {
      var _a, _b, _c, _d, _e;
      (_a = this.$alpha) == null ? void 0 : _a.removeEventListener("mousedown", this.onMouseDown);
      (_b = this.$alpha) == null ? void 0 : _b.removeEventListener("mouseup", this.onMouseUp);
      (_c = this.$alpha) == null ? void 0 : _c.removeEventListener("touchmove", this.onChange);
      (_d = this.$alpha) == null ? void 0 : _d.removeEventListener("touchstart", this.onChange);
      (_e = this.$pointer) == null ? void 0 : _e.removeEventListener("keydown", this.onKeyDown);
      document.removeEventListener(CUSTOM_EVENT_COLOR_HSV_CHANGED, this.hsvChanged);
      document.removeEventListener(CUSTOM_EVENT_COLOR_HUE_CHANGED, this.hueChanged);
      document.removeEventListener(CUSTOM_EVENT_COLOR_ALPHA_CHANGED, this.alphaChanged);
    }
    attributeChangedCallback(_attrName, _oldVal, newVal) {
      const color = parseColor(newVal);
      const hsv = color.toHsv();
      this.alpha = hsv.a;
      this.hue = hsv.h;
      this.saturation = hsv.s;
      this.value = hsv.v;
      this.render(false);
    }
  };
  var alpha_default2 = Alpha;

  // src/ui/fields/fields.pcss
  var fields_default = ":root{--tool-cool-color-picker-field-border-color:#cecece;--tool-cool-color-picker-field-label-color:#000}.fields{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica Neue,Noto Sans,Liberation Sans,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-size:11px;grid-template-columns:60px 35px 35px 35px 34px;text-align:center;display:grid;gap:.25rem;margin-top:.25rem;color:var(--tool-cool-color-picker-field-label-color,#000)}.fields input{background:#fff;border-width:1px;border-style:solid;border-color:var(--tool-cool-color-picker-field-border-color,#cecece);padding:1px 3px;border-radius:2px;color:#000;font-family:inherit;font-size:100%;line-height:inherit;margin:0;box-sizing:border-box}";

  // src/ui/fields/fields.ts
  var Fields = class extends HTMLElement {
    constructor() {
      super();
      __publicField(this, "cid");
      __publicField(this, "color", new TinyColor("#000"));
      __publicField(this, "$hex");
      __publicField(this, "$r");
      __publicField(this, "$g");
      __publicField(this, "$b");
      __publicField(this, "$a");
      __publicField(this, "hex", "");
      __publicField(this, "r", 0);
      __publicField(this, "g", 0);
      __publicField(this, "b", 0);
      __publicField(this, "a", 1);
      this.attachShadow({
        mode: "open"
      });
      this.hsvChanged = this.hsvChanged.bind(this);
      this.hueChanged = this.hueChanged.bind(this);
      this.alphaChanged = this.alphaChanged.bind(this);
      this.onHexChange = this.onHexChange.bind(this);
      this.render = this.render.bind(this);
      this.onRedChange = this.onRedChange.bind(this);
      this.onGreenChange = this.onGreenChange.bind(this);
      this.onBlueChange = this.onBlueChange.bind(this);
      this.onAlphaChange = this.onAlphaChange.bind(this);
      this.onRedKeyDown = this.onRedKeyDown.bind(this);
      this.onBlueKeyDown = this.onBlueKeyDown.bind(this);
      this.onGreenKeyDown = this.onGreenKeyDown.bind(this);
      this.onAlphaKeyDown = this.onAlphaKeyDown.bind(this);
    }
    static get observedAttributes() {
      return ["color"];
    }
    hueChanged(evt) {
      if (!evt || !evt.detail || !evt.detail.cid)
        return;
      if (evt.detail.cid !== this.cid)
        return;
      const hsv = this.color.toHsv();
      this.color = new TinyColor({
        h: Number(evt.detail.h),
        s: hsv.s,
        v: hsv.v,
        a: hsv.a
      });
      this.render();
    }
    alphaChanged(evt) {
      if (!evt || !evt.detail || !evt.detail.cid)
        return;
      if (evt.detail.cid !== this.cid)
        return;
      const rgba = this.color.toRgb();
      rgba.a = evt.detail.a;
      this.color = new TinyColor(rgba);
      this.render();
    }
    hsvChanged(evt) {
      if (!evt || !evt.detail || !evt.detail.cid)
        return;
      if (evt.detail.cid !== this.cid)
        return;
      this.color = new TinyColor({
        h: evt.detail.h,
        s: evt.detail.s,
        v: evt.detail.v,
        a: this.color.toHsv().a
      });
      this.render();
    }
    render() {
      var _a, _b, _c, _d, _e;
      const rgba = this.color.toRgb();
      this.r = rgba.r;
      this.g = rgba.g;
      this.b = rgba.b;
      this.a = rgba.a;
      this.hex = this.color.toHex();
      if (this.$hex && ((_a = this.shadowRoot) == null ? void 0 : _a.activeElement) !== this.$hex) {
        this.$hex.value = this.hex.toUpperCase();
      }
      if (this.$r && ((_b = this.shadowRoot) == null ? void 0 : _b.activeElement) !== this.$r) {
        this.$r.value = this.r.toString();
      }
      if (this.$g && ((_c = this.shadowRoot) == null ? void 0 : _c.activeElement) !== this.$g) {
        this.$g.value = this.g.toString();
      }
      if (this.$b && ((_d = this.shadowRoot) == null ? void 0 : _d.activeElement) !== this.$b) {
        this.$b.value = this.b.toString();
      }
      if (this.$a && ((_e = this.shadowRoot) == null ? void 0 : _e.activeElement) !== this.$a) {
        this.$a.value = Math.round(this.a * 100).toString();
      }
    }
    onFieldKeyDown(evt, type) {
      var _a, _b;
      const rgba = this.color.toRgb();
      switch (evt.key) {
        case "ArrowUp": {
          if (type === "r") {
            this.r = Math.min(255, rgba.r + 1);
            rgba.r = this.r;
            const hsv = new TinyColor(rgba).toHsv();
            sendHsvCustomEvent(this.cid, hsv.h, hsv.s, hsv.v);
            this.$r.value = this.r.toString();
            this.render();
          }
          if (type === "g") {
            this.g = Math.min(255, rgba.g + 1);
            rgba.g = this.g;
            const hsv = new TinyColor(rgba).toHsv();
            sendHsvCustomEvent(this.cid, hsv.h, hsv.s, hsv.v);
            this.$g.value = this.g.toString();
            this.render();
          }
          if (type === "b") {
            this.b = Math.min(255, rgba.b + 1);
            rgba.b = this.b;
            const hsv = new TinyColor(rgba).toHsv();
            sendHsvCustomEvent(this.cid, hsv.h, hsv.s, hsv.v);
            this.$b.value = this.b.toString();
            this.render();
          }
          if (type === "a") {
            this.a = Math.max(0, Math.min(this.a + 0.01, 1));
            this.$a.value = Math.round(this.a * 100).toString();
            const rgba2 = this.color.toRgb();
            rgba2.a = this.a;
            this.color = new TinyColor(rgba2);
            this.render();
            sendAlphaCustomEvent(this.cid, this.a);
          }
          break;
        }
        case "ArrowDown": {
          if (type === "r") {
            this.r = Math.max(0, rgba.r - 1);
            rgba.r = this.r;
            const hsv = new TinyColor(rgba).toHsv();
            sendHsvCustomEvent(this.cid, hsv.h, hsv.s, hsv.v);
            this.$r.value = this.r.toString();
            this.render();
          }
          if (type === "g") {
            this.g = Math.max(0, rgba.g - 1);
            rgba.g = this.g;
            const hsv = new TinyColor(rgba).toHsv();
            sendHsvCustomEvent(this.cid, hsv.h, hsv.s, hsv.v);
            this.$g.value = this.g.toString();
            this.render();
          }
          if (type === "b") {
            this.b = Math.max(0, rgba.b - 1);
            rgba.b = this.b;
            const hsv = new TinyColor(rgba).toHsv();
            sendHsvCustomEvent(this.cid, hsv.h, hsv.s, hsv.v);
            this.$b.value = this.b.toString();
            this.render();
          }
          if (type === "a") {
            this.a = Math.max(0, this.a - 0.01);
            this.$a.value = Math.round(this.a * 100).toString();
            const rgba2 = this.color.toRgb();
            rgba2.a = this.a;
            this.color = new TinyColor(rgba2);
            this.render();
            sendAlphaCustomEvent(this.cid, this.a);
          }
          break;
        }
        case "Escape": {
          if ((_a = this.shadowRoot) == null ? void 0 : _a.activeElement) {
            const $el = this.shadowRoot.activeElement;
            $el.blur();
          }
          this.render();
          break;
        }
        case "Enter": {
          if ((_b = this.shadowRoot) == null ? void 0 : _b.activeElement) {
            const $el = this.shadowRoot.activeElement;
            $el.blur();
          }
          this.render();
          break;
        }
      }
    }
    onRedKeyDown(evt) {
      this.onFieldKeyDown(evt, "r");
    }
    onGreenKeyDown(evt) {
      this.onFieldKeyDown(evt, "g");
    }
    onBlueKeyDown(evt) {
      this.onFieldKeyDown(evt, "b");
    }
    onAlphaKeyDown(evt) {
      this.onFieldKeyDown(evt, "a");
    }
    onHexChange(evt) {
      const $target = evt.target;
      if ($target.value.length !== 6)
        return;
      const updatedColor = new TinyColor(`#${$target.value}`);
      if (updatedColor.isValid) {
        this.color = updatedColor;
        const hsv = this.color.toHsv();
        sendHsvCustomEvent(this.cid, hsv.h, hsv.s, hsv.v);
      }
    }
    onRedChange(evt) {
      const $target = evt.target;
      const fixedValue = fixRGB($target.value);
      if (fixedValue.toString() === $target.value) {
        const rgba = this.color.toRgb();
        rgba.r = fixedValue;
        const hsv = new TinyColor(rgba).toHsv();
        sendHsvCustomEvent(this.cid, hsv.h, hsv.s, hsv.v);
      }
    }
    onGreenChange(evt) {
      const $target = evt.target;
      const fixedValue = fixRGB($target.value);
      if (fixedValue.toString() === $target.value) {
        const rgba = this.color.toRgb();
        rgba.g = fixedValue;
        const hsv = new TinyColor(rgba).toHsv();
        sendHsvCustomEvent(this.cid, hsv.h, hsv.s, hsv.v);
      }
    }
    onBlueChange(evt) {
      const $target = evt.target;
      const fixedValue = fixRGB($target.value);
      if (fixedValue.toString() === $target.value) {
        const rgba = this.color.toRgb();
        rgba.b = fixedValue;
        const hsv = new TinyColor(rgba).toHsv();
        sendHsvCustomEvent(this.cid, hsv.h, hsv.s, hsv.v);
      }
    }
    onAlphaChange(evt) {
      const $target = evt.target;
      const fixedValue = fixPercent($target.value);
      if (fixedValue.toString() === $target.value) {
        sendAlphaCustomEvent(this.cid, fixedValue / 100);
      }
    }
    connectedCallback() {
      if (!this.shadowRoot)
        return;
      this.cid = this.getAttribute("cid") || "";
      this.color = parseColor(this.getAttribute("color"));
      const rgba = this.color.toRgb();
      this.r = rgba.r;
      this.g = rgba.g;
      this.b = rgba.b;
      this.a = rgba.a;
      this.hex = this.color.toHex();
      const hexId = getUniqueId();
      const rId = getUniqueId();
      const gId = getUniqueId();
      const bId = getUniqueId();
      const aId = getUniqueId();
      this.shadowRoot.innerHTML = `
           <style>${fields_default}</style>
           <div class="fields">
               <input id="hex-${hexId}" type="text" value="${this.hex.toUpperCase()}" data-type="hex" />
               <input id="r-${rId}" type="text" value="${this.r}" data-type="r" />
               <input id="g-${gId}" type="text" value="${this.g}" data-type="g" />
               <input id="b-${bId}" type="text" value="${this.b}" data-type="b" />
               <input id="a-${aId}" type="text" value="${Math.round(this.a * 100)}" data-type="a" />
               
               <label for="hex-${hexId}">Hex</label>
               <label for="r-${rId}">R</label>
               <label for="g-${gId}">G</label>
               <label for="b-${bId}">B</label>
               <label for="a-${aId}">A</label>
           </div>
        `;
      this.$hex = this.shadowRoot.getElementById(`hex-${hexId}`);
      this.$r = this.shadowRoot.getElementById(`r-${rId}`);
      this.$g = this.shadowRoot.getElementById(`g-${gId}`);
      this.$b = this.shadowRoot.getElementById(`b-${bId}`);
      this.$a = this.shadowRoot.getElementById(`a-${aId}`);
      document.addEventListener(CUSTOM_EVENT_COLOR_HSV_CHANGED, this.hsvChanged);
      document.addEventListener(CUSTOM_EVENT_COLOR_HUE_CHANGED, this.hueChanged);
      document.addEventListener(CUSTOM_EVENT_COLOR_ALPHA_CHANGED, this.alphaChanged);
      this.$hex.addEventListener("input", this.onHexChange);
      this.$r.addEventListener("input", this.onRedChange);
      this.$g.addEventListener("input", this.onGreenChange);
      this.$b.addEventListener("input", this.onBlueChange);
      this.$a.addEventListener("input", this.onAlphaChange);
      this.$hex.addEventListener("blur", this.render);
      this.$r.addEventListener("blur", this.render);
      this.$g.addEventListener("blur", this.render);
      this.$b.addEventListener("blur", this.render);
      this.$a.addEventListener("blur", this.render);
      this.$r.addEventListener("keydown", this.onRedKeyDown);
      this.$g.addEventListener("keydown", this.onGreenKeyDown);
      this.$b.addEventListener("keydown", this.onBlueKeyDown);
      this.$a.addEventListener("keydown", this.onAlphaKeyDown);
    }
    disconnectedCallback() {
      document.removeEventListener(CUSTOM_EVENT_COLOR_HSV_CHANGED, this.hsvChanged);
      document.removeEventListener(CUSTOM_EVENT_COLOR_HUE_CHANGED, this.hueChanged);
      document.removeEventListener(CUSTOM_EVENT_COLOR_ALPHA_CHANGED, this.alphaChanged);
      this.$hex.removeEventListener("input", this.onHexChange);
      this.$r.removeEventListener("input", this.onRedChange);
      this.$g.removeEventListener("input", this.onGreenChange);
      this.$b.removeEventListener("input", this.onBlueChange);
      this.$a.removeEventListener("input", this.onAlphaChange);
      this.$hex.removeEventListener("blur", this.render);
      this.$r.removeEventListener("blur", this.render);
      this.$g.removeEventListener("blur", this.render);
      this.$b.removeEventListener("blur", this.render);
      this.$a.removeEventListener("blur", this.render);
      this.$r.removeEventListener("keydown", this.onRedKeyDown);
      this.$g.removeEventListener("keydown", this.onGreenKeyDown);
      this.$b.removeEventListener("keydown", this.onBlueKeyDown);
      this.$a.removeEventListener("keydown", this.onAlphaKeyDown);
    }
    attributeChangedCallback(_attrName, _oldVal, newVal) {
      this.color = parseColor(newVal);
      this.render();
    }
  };
  var fields_default2 = Fields;

  // src/ui/popup/popup.ts
  var ColorPickerPopup = class extends HTMLElement {
    constructor() {
      super();
      __publicField(this, "cid");
      __publicField(this, "popupPosition", "left");
      __publicField(this, "$popup");
      __publicField(this, "color", "#000");
      __publicField(this, "colorIndex", -1);
      __publicField(this, "themeColors", []);
      if (!customElements.get("toolcool-color-picker-theme-colors")) {
        customElements.define("toolcool-color-picker-theme-colors", themecolors_default2);
      }
      if (!customElements.get("toolcool-color-picker-saturation")) {
        customElements.define("toolcool-color-picker-saturation", saturation_default2);
      }
      if (!customElements.get("toolcool-color-picker-hue")) {
        customElements.define("toolcool-color-picker-hue", hue_default2);
      }
      if (!customElements.get("toolcool-color-picker-alpha")) {
        customElements.define("toolcool-color-picker-alpha", alpha_default2);
      }
      if (!customElements.get("toolcool-color-picker-fields")) {
        customElements.define("toolcool-color-picker-fields", fields_default2);
      }
      this.cid = this.getAttribute("cid") || "";
      this.prevent = this.prevent.bind(this);
      this.attachShadow({
        mode: "open"
      });
    }
    static get observedAttributes() {
      return ["color", "theme-colors", "color-index", "popup-position"];
    }
    prevent(evt) {
      evt.stopPropagation();
    }
    connectedCallback() {
      var _a, _b;
      if (!this.shadowRoot)
        return;
      const themeColorsStr = this.getAttribute("theme-colors") || "[]";
      this.color = this.getAttribute("color") || "#000";
      this.themeColors = JSON.parse(themeColorsStr);
      this.colorIndex = parseInt(this.getAttribute("color-index") || "-1");
      this.popupPosition = this.getAttribute("popup-position") || "left";
      this.shadowRoot.innerHTML = `
           <style>${popup_default}</style>
           <div class='popup'>
                <toolcool-color-picker-theme-colors color-index='${this.colorIndex}' theme-colors='${themeColorsStr}' cid='${this.cid}'></toolcool-color-picker-theme-colors>
                <toolcool-color-picker-saturation color='${this.color}' cid='${this.cid}'></toolcool-color-picker-saturation>
                <toolcool-color-picker-hue color='${this.color}' cid='${this.cid}'></toolcool-color-picker-hue>
                <toolcool-color-picker-alpha color='${this.color}' cid='${this.cid}'></toolcool-color-picker-alpha>
                <toolcool-color-picker-fields color='${this.color}' cid='${this.cid}'></toolcool-color-picker-fields>
           </div>
        `;
      this.$popup = this.shadowRoot.querySelector(".popup");
      (_a = this.$popup) == null ? void 0 : _a.addEventListener("mousedown", this.prevent);
      (_b = this.$popup) == null ? void 0 : _b.classList.toggle("right", this.popupPosition === "right");
    }
    disconnectedCallback() {
      var _a;
      (_a = this.$popup) == null ? void 0 : _a.removeEventListener("mousedown", this.prevent);
    }
    attributeChangedCallback(attrName, _oldVal, newVal) {
      var _a, _b, _c, _d, _e, _f;
      if (attrName === "popup-position") {
        this.popupPosition = newVal;
        if (this.$popup) {
          this.$popup.classList.toggle("right", this.popupPosition === "right");
        }
      }
      if (attrName === "theme-colors") {
        this.themeColors = JSON.parse(newVal || "[]");
        const $themeColor = (_a = this.shadowRoot) == null ? void 0 : _a.querySelector("toolcool-color-picker-theme-colors");
        if ($themeColor) {
          $themeColor.setAttribute("theme-colors", newVal);
        }
      }
      if (attrName === "color-index") {
        this.colorIndex = parseInt(newVal);
        const $themeColor = (_b = this.shadowRoot) == null ? void 0 : _b.querySelector("toolcool-color-picker-theme-colors");
        if ($themeColor) {
          $themeColor.setAttribute("color-index", newVal);
        }
      }
      if (attrName === "color") {
        this.color = newVal;
        const $saturation = (_c = this.shadowRoot) == null ? void 0 : _c.querySelector("toolcool-color-picker-saturation");
        const $hue = (_d = this.shadowRoot) == null ? void 0 : _d.querySelector("toolcool-color-picker-hue");
        const $alpha = (_e = this.shadowRoot) == null ? void 0 : _e.querySelector("toolcool-color-picker-alpha");
        const $fields = (_f = this.shadowRoot) == null ? void 0 : _f.querySelector("toolcool-color-picker-fields");
        if ($saturation) {
          $saturation.setAttribute("color", this.color);
        }
        if ($hue) {
          $hue.setAttribute("color", this.color);
        }
        if ($alpha) {
          $alpha.setAttribute("color", this.color);
        }
        if ($fields) {
          $fields.setAttribute("color", this.color);
        }
      }
    }
  };
  var popup_default2 = ColorPickerPopup;

  // src/app/color-picker.ts
  var buttonPredefinedSizes = {
    sm: "0.875rem",
    md: "1.2rem",
    lg: "1.5rem",
    xl: "2.25rem",
    "2xl": "3rem",
    "3xl": "3.75rem",
    "4xl": "4.5rem"
  };
  var ColorPicker = class extends HTMLElement {
    constructor() {
      super();
      __publicField(this, "cid");
      __publicField(this, "$button");
      __publicField(this, "$buttonColor");
      __publicField(this, "$popupBox");
      __publicField(this, "stateDefaults", {
        isPopupVisible: false,
        popupPosition: "left",
        initialColor: new TinyColor("#000"),
        color: new TinyColor("#000"),
        colorIndex: -1,
        themeColors: [],
        buttonWidth: null,
        buttonHeight: null,
        buttonPadding: null
      });
      __publicField(this, "state");
      this.cid = getUniqueId();
      if (!customElements.get("toolcool-color-picker-popup")) {
        customElements.define("toolcool-color-picker-popup", popup_default2);
      }
      this.attachShadow({
        mode: "open"
      });
      this.toggle = this.toggle.bind(this);
      this.onKeyDown = this.onKeyDown.bind(this);
      this.clickedOutside = this.clickedOutside.bind(this);
      this.stopPropagation = this.stopPropagation.bind(this);
      this.hsvChanged = this.hsvChanged.bind(this);
      this.hueChanged = this.hueChanged.bind(this);
      this.alphaChanged = this.alphaChanged.bind(this);
      this.colorIndexChanged = this.colorIndexChanged.bind(this);
      this.buttonClicked = this.buttonClicked.bind(this);
      this.formatButtonSize = this.formatButtonSize.bind(this);
      this.initState();
    }
    static get observedAttributes() {
      return ["color", "theme-colors", "color-index", "popup-position", "button-width", "button-height", "button-padding"];
    }
    set color(userColor) {
      this.state.color = new TinyColor(userColor);
    }
    get color() {
      return this.state.color;
    }
    set colorIndex(index) {
      this.state.colorIndex = index;
    }
    get colorIndex() {
      return this.state.colorIndex;
    }
    set themeColors(val) {
      this.state.themeColors = val;
    }
    get themeColors() {
      return this.state.themeColors;
    }
    get hex() {
      return this.state.color.toHexString().toUpperCase();
    }
    get hex8() {
      return this.state.color.toHex8String().toUpperCase();
    }
    get rgb() {
      return this.state.color.toRgbString();
    }
    get rgba() {
      return rgbaToString(this.state.color);
    }
    get hsl() {
      return this.state.color.toHslString();
    }
    get hsla() {
      return hslaToString(this.state.color);
    }
    get hsv() {
      return this.state.color.toHsvString();
    }
    get hsva() {
      return hsvaToString(this.state.color);
    }
    get opened() {
      return this.state.isPopupVisible;
    }
    set opened(isOpened) {
      this.state.isPopupVisible = isOpened;
    }
    initState() {
      const scope = this;
      this.state = new Proxy(scope.stateDefaults, {
        set(target, key, value, _receiver) {
          target[key] = value;
          if (key === "isPopupVisible") {
            scope.onPopupVisibilityChange();
          }
          if (key === "popupPosition") {
            scope.onPopupPosChange();
          }
          if (key === "initialColor") {
            scope.onInitialColorChange();
          }
          if (key === "color") {
            scope.onColorChange();
          }
          if (key === "colorIndex") {
            scope.onColorIndexChange();
          }
          if (key === "themeColors") {
            scope.onThemeColorChange();
          }
          if (key === "buttonWidth" || key === "buttonHeight" || key === "buttonPadding") {
            scope.setButtonSize();
          }
          return true;
        }
      });
    }
    onPopupVisibilityChange() {
      if (!this.$popupBox)
        return;
      const colorStr = this.state.color.toRgbString();
      const themeColorStr = JSON.stringify(this.themeColors);
      const popupPos = this.state.popupPosition;
      this.$popupBox.innerHTML = this.state.isPopupVisible ? `<toolcool-color-picker-popup color='${colorStr}' color-index='${this.colorIndex}' theme-colors='${themeColorStr}' cid='${this.cid}' popup-position='${popupPos}' />` : "";
    }
    onPopupPosChange() {
      if (!this.$popupBox)
        return;
      const $popup = this.$popupBox.querySelector("toolcool-color-picker-popup");
      if (!$popup)
        return;
      $popup.setAttribute("popup-position", this.state.popupPosition);
    }
    onInitialColorChange() {
      var _a;
      const bgColor = rgbaToString(this.state.color);
      if (this.$buttonColor) {
        this.$buttonColor.style.backgroundColor = bgColor;
      }
      const $popup = (_a = this.shadowRoot) == null ? void 0 : _a.querySelector("toolcool-color-picker-popup");
      if ($popup) {
        $popup.setAttribute("color", bgColor);
      }
    }
    setButtonSize() {
      if (!this.$button)
        return;
      if (this.state.buttonWidth) {
        this.$button.style.width = this.formatButtonSize(this.state.buttonWidth);
      }
      if (this.state.buttonHeight) {
        this.$button.style.height = this.formatButtonSize(this.state.buttonHeight);
      }
      if (this.state.buttonPadding) {
        this.$button.style.padding = this.state.buttonPadding;
      }
    }
    onColorChange() {
      if (this.$buttonColor) {
        this.$buttonColor.style.backgroundColor = rgbaToString(this.state.color);
      }
    }
    fireEvent() {
      this.dispatchEvent(new CustomEvent("change", {
        bubbles: true,
        detail: {
          hex: this.hex,
          hex8: this.hex8,
          rgb: this.rgb,
          rgba: this.rgba,
          hsl: this.hsl,
          hsla: this.hsla,
          hsv: this.hsv,
          hsva: this.hsva,
          color: this.color,
          colorIndex: this.colorIndex,
          themeColors: this.themeColors
        }
      }));
    }
    onColorIndexChange() {
      var _a;
      if (this.state.colorIndex >= 0 && this.state.colorIndex < this.state.themeColors.length || 0) {
        const rgba = new TinyColor(this.state.themeColors[this.state.colorIndex]).toRgb();
        rgba.a = this.state.color.a;
        this.state.color = new TinyColor(rgba);
        this.state.initialColor = this.state.color;
      }
      const $popup = (_a = this.shadowRoot) == null ? void 0 : _a.querySelector("toolcool-color-picker-popup");
      if ($popup) {
        $popup.setAttribute("color-index", "" + this.state.colorIndex);
      }
    }
    onThemeColorChange() {
      var _a;
      if (this.state.colorIndex >= 0 && this.state.colorIndex < this.state.themeColors.length || 0) {
        const rgba = new TinyColor(this.state.themeColors[this.state.colorIndex]).toRgb();
        rgba.a = this.state.color.a;
        this.state.color = new TinyColor(rgba);
        this.state.initialColor = this.state.color;
      }
      const $popup = (_a = this.shadowRoot) == null ? void 0 : _a.querySelector("toolcool-color-picker-popup");
      if ($popup) {
        $popup.setAttribute("theme-colors", JSON.stringify(this.state.themeColors));
      }
    }
    hsvChanged(evt) {
      if (!evt || !evt.detail || !evt.detail.cid)
        return;
      if (evt.detail.cid !== this.cid)
        return;
      this.state.color = new TinyColor({
        h: evt.detail.h,
        s: evt.detail.s,
        v: evt.detail.v,
        a: this.state.color.toHsv().a
      });
      this.state.colorIndex = -1;
      this.fireEvent();
    }
    hueChanged(evt) {
      if (!evt || !evt.detail || !evt.detail.cid)
        return;
      if (evt.detail.cid !== this.cid)
        return;
      const hsv = this.state.color.toHsv();
      this.state.color = new TinyColor({
        h: evt.detail.h,
        s: hsv.s,
        v: hsv.v,
        a: hsv.a
      });
      this.state.colorIndex = -1;
      this.fireEvent();
    }
    alphaChanged(evt) {
      if (!evt || !evt.detail || !evt.detail.cid)
        return;
      if (evt.detail.cid !== this.cid)
        return;
      const rgba = this.state.color.toRgb();
      rgba.a = evt.detail.a;
      this.state.color = new TinyColor(rgba);
      this.fireEvent();
    }
    colorIndexChanged(evt) {
      if (!evt || !evt.detail || !evt.detail.cid)
        return;
      if (evt.detail.cid !== this.cid)
        return;
      this.state.colorIndex = parseInt(evt.detail.i || "-1");
      if (this.state.colorIndex >= 0 && this.state.colorIndex < this.state.themeColors.length || 0) {
        const rgba = new TinyColor(this.state.themeColors[this.state.colorIndex]).toRgb();
        rgba.a = this.state.color.a;
        this.state.color = new TinyColor(rgba);
      } else {
        this.state.color = new TinyColor();
      }
      this.fireEvent();
    }
    themeColorChanged(evt) {
      if (!evt || !evt.detail || !evt.detail.cid)
        return;
      if (evt.detail.cid !== this.cid)
        return;
      this.state.themeColors = JSON.parse(evt.detail.tc || "[]");
      if (this.state.colorIndex >= 0 && this.state.colorIndex < this.state.themeColors.length || 0) {
        const rgba = new TinyColor(this.state.themeColors[this.state.colorIndex]).toRgb();
        rgba.a = this.state.color.a;
        this.state.color = new TinyColor(rgba);
      } else {
        this.state.color = new TinyColor();
      }
      this.fireEvent();
    }
    buttonClicked(evt) {
      if (!evt || !evt.detail || !evt.detail.cid)
        return;
      if (evt.detail.cid === this.cid)
        return;
      this.state.isPopupVisible = false;
    }
    clickedOutside() {
      this.state.isPopupVisible = false;
    }
    toggle() {
      const isVisible = this.state.isPopupVisible;
      window.setTimeout(() => {
        this.state.isPopupVisible = !isVisible;
        sendButtonClickedCustomEvent(this.cid);
      }, 0);
    }
    onKeyDown(evt) {
      if (evt.key === "Escape") {
        this.state.isPopupVisible = false;
      }
    }
    stopPropagation(evt) {
      evt.stopPropagation();
    }
    formatButtonSize(size) {
      var _a;
      return (_a = buttonPredefinedSizes[size]) != null ? _a : size;
    }
    connectedCallback() {
      var _a, _b, _c;
      if (!this.shadowRoot)
        return;
      this.state.initialColor = parseColor(this.getAttribute("color"));
      this.state.color = parseColor(this.getAttribute("color"));
      this.state.colorIndex = parseInt(this.getAttribute("color-index") || "-1");
      this.state.themeColors = JSON.parse(this.getAttribute("theme-colors") || "[]");
      this.state.color = parseColor(this.getAttribute("color"));
      this.state.popupPosition = this.getAttribute("popup-position") || "left";
      this.state.buttonWidth = this.getAttribute("button-width");
      this.state.buttonHeight = this.getAttribute("button-height");
      this.state.buttonPadding = this.getAttribute("button-padding");
      this.shadowRoot.innerHTML = `
            <style>
                ${styles_default} 
            </style>
            <div class="color-picker" >
                <button
                    type="button"
                    tabIndex="0"
                    class="button"
                    title="Select Color">
                    <span class="button-color" style="background: ${rgbaToString(this.state.color)};"></span>
                </button>
                <div data-popup-box></div>
            </div>
        `;
      this.$button = this.shadowRoot.querySelector(".button");
      this.$buttonColor = this.shadowRoot.querySelector(".button-color");
      (_a = this.$button) == null ? void 0 : _a.addEventListener("click", this.toggle);
      (_b = this.$button) == null ? void 0 : _b.addEventListener("keydown", this.onKeyDown);
      (_c = this.$button) == null ? void 0 : _c.addEventListener("mousedown", this.stopPropagation);
      this.$popupBox = this.shadowRoot.querySelector("[data-popup-box]");
      this.setButtonSize();
      document.addEventListener("mousedown", this.clickedOutside);
      document.addEventListener(CUSTOM_EVENT_COLOR_HSV_CHANGED, this.hsvChanged);
      document.addEventListener(CUSTOM_EVENT_COLOR_HUE_CHANGED, this.hueChanged);
      document.addEventListener(CUSTOM_EVENT_COLOR_ALPHA_CHANGED, this.alphaChanged);
      document.addEventListener(CUSTOM_EVENT_COLOR_INDEX_CHANGED, this.colorIndexChanged);
      document.addEventListener(CUSTOM_EVENT_THEME_COLOR_CHANGED, this.themeColorChanged);
      document.addEventListener(CUSTOM_EVENT_BUTTON_CLICKED, this.buttonClicked);
    }
    disconnectedCallback() {
      var _a, _b, _c;
      (_a = this.$button) == null ? void 0 : _a.removeEventListener("click", this.toggle);
      (_b = this.$button) == null ? void 0 : _b.removeEventListener("keydown", this.onKeyDown);
      (_c = this.$button) == null ? void 0 : _c.removeEventListener("mousedown", this.stopPropagation);
      document.removeEventListener("mousedown", this.clickedOutside);
      document.removeEventListener(CUSTOM_EVENT_COLOR_HSV_CHANGED, this.hsvChanged);
      document.removeEventListener(CUSTOM_EVENT_COLOR_HUE_CHANGED, this.hueChanged);
      document.removeEventListener(CUSTOM_EVENT_COLOR_ALPHA_CHANGED, this.alphaChanged);
      document.removeEventListener(CUSTOM_EVENT_COLOR_INDEX_CHANGED, this.colorIndexChanged);
      document.removeEventListener(CUSTOM_EVENT_THEME_COLOR_CHANGED, this.themeColorChanged);
      document.removeEventListener(CUSTOM_EVENT_BUTTON_CLICKED, this.buttonClicked);
    }
    attributeChangedCallback(attrName) {
      switch (attrName) {
        case "color": {
          this.state.initialColor = parseColor(this.getAttribute("color"));
          this.state.color = parseColor(this.getAttribute("color"));
          this.onInitialColorChange();
          break;
        }
        case "color-index": {
          this.state.colorIndex = parseInt(this.getAttribute("color-index") || "-1");
          break;
        }
        case "theme-colors": {
          const colorThemeStr = this.getAttribute("theme-colors") || "[]";
          this.state.themeColors = JSON.parse(colorThemeStr);
          break;
        }
        case "popup-position": {
          this.state.popupPosition = this.getAttribute("popup-position") || "left";
          this.onPopupPosChange();
          break;
        }
        case "button-width": {
          this.state.buttonWidth = this.getAttribute("button-width");
          this.setButtonSize();
          break;
        }
        case "button-height": {
          this.state.buttonHeight = this.getAttribute("button-height");
          this.setButtonSize();
          break;
        }
        case "button-padding": {
          this.state.buttonPadding = this.getAttribute("button-padding");
          this.setButtonSize();
          break;
        }
      }
    }
  };
  var color_picker_default = ColorPicker;

  // src/index.ts
  if (!customElements.get("toolcool-color-picker")) {
    customElements.define("toolcool-color-picker", color_picker_default);
  }
})();
